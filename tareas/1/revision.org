* Los alumnos y el asesor
- Â¡Muy bien por especificar los valores de forma fÃ¡cilmente
  parametrizable!

** Aranzua Chavez, Carranza Ochoa
- DocumentaciÃ³n :: [[./AranzuaChavez-CarranzaOchoa/README.md][README.md]]
- Archivos :: [[./AranzuaChavez-CarranzaOchoa/tarea1.py][tarea1.py]]
- Comentarios ::
  - Los =alumno()= no despiertan al profe sÃ³lo si estÃ¡ dormido: Cada
    pregunta lleva un =despertar.release()=
    - Â¿O sera que tal vez el nombre es incorrecto? Porque el =profesor()=
      estÃ¡ despierto en todo momento (no se duerme; sÃ³lo comienza
      diciendo que estÃ¡ dormido, e incrementa =aux=, con lo que su
      sueÃ±o sÃ³lo le dura un ciclo de un =while= vacÃ­o ğŸ™. Â¡Pobrecito!
      ğŸ˜«
    - TendrÃ­a que ser el =profesor()=, no el =alumno()=, el que
      anunciara =PROFE DORMIDO SALIENDO=, Â¿no? O en todo caso, el
      =alumno()= deberÃ­a anunciar =SALIENDO= y el profe, viendo que no
      queda nadie, decir =Hora de dormir un rato=.
  - La idea de salir cuando =NUM_ALUMNOS == id+1= no es mala, pero
    puedes estar cortando algunas preguntas: Si el =alumno()= 4 tiene
    sÃ³lo una pregunta y el 3 tiene 4, Â¡probablemente el =alumno()= 4
    salga antes de que el 3 haya tenido tiempo de plantear todas sus
    preguntas!
    - Salir mediante un =os._exit(0)= es una idea original e
      interesante. No te voy a decir que me encanta, sobre todo porque
      no considera a todos los demÃ¡s hilos, pero es efectiva ğŸ˜‰
  - La interacciÃ³n de plantear y responder preguntas es correcta
  - Respecto a sus preguntas:
    - Si omites el =os._exit()=, el =profesor()= se queda esperando en
      =despertar.acquire()=.
    - Â¿De quÃ© otra manera modelarlo? Â¡AcompÃ¡Ã±enme a revisar las
      entregas de sus compaÃ±eros! ğŸ˜‰ Seguro encunentran mucho mÃ¡s si
      buscan en Internet el /problema del barbero durmiente/
      (/sleeping barber/).
    - En Python, hace falta declarar como =global= todas las variables
      que uses dentro de una funciÃ³n y que pueda caber duda de dÃ³nde
      vienen, esto es, cuando su primer uso dentro de una funciÃ³n es
      una asignaciÃ³n. Esto se hace porque en Python, al igual que en
      muchos lenguajes, se intenta que las variables pertenezcan al
      /Ã¡mbito mÃ¡s acotado posible/: Que se mantengan como /locales/ a
      cada funciÃ³n.

      En varios lenguajes, de hecho, se pueden declarar variables
      locales a cualquier bloque, por muy anidado que estÃ©, y no son
      visibles fuera de Ã©ste.

      En el caso de ustedes, =aux= sÃ³lo se usa dentro de =profesor()=,
      asÃ­ que no hace falta declararla en =alumno()=. PodrÃ­an no
      declarar a =aux= en la parte externa, sino que Ãºnicamente dentro
      de la funciÃ³n.
- CalificaciÃ³n :: 8

** Armenta Fabian, Sierra Nayeli
- DocumentaciÃ³n :: [[./ArmentaFabian-SierraNayeli/Tarea1.txt][Tarea1.txt]]
- Archivos :: [[./ArmentaFabian-SierraNayeli/Alumno_Asesor.py][Alumno_Asesor.py]]
- Comentarios ::
  - A veces, lo que decimos los profesores no es muy Ãºtil... Pero en
    esta implementaciÃ³n no hay ni siquiera comunicaciÃ³n entre el
    =alumno()= y el =profesor()=: El alumno solito entra, pregunta,
    espera, se responde solito y decide que es hora de irse
    - El mutex =pregunta= sÃ³lo evita que mÃ¡s de un alumno estÃ©
      preguntando a la vez, pero no hay ninguna seÃ±alizaciÃ³n que haga
      que el =profesor()= haga algo
    - El profesor sÃ³lo hace una espera activa (aunque sea con un
      =time.sleep(0.3)=) y anuncia que se va a dormir si no ve a
      nadie, pero no emplea ningÃºn mecanismo de sincronizaciÃ³n
    - Los semÃ¡foros =tocar_Puerta=, =dudas= y =alum= son declarados,
      pero no utilizados
  - Los Ãºnicos usos de sincronizaciÃ³n que veo son el multiplex
    =cubiculo= y el mutex =pregunta=.
- CalificaciÃ³n :: 6

** Morales Ortega
- DocumentaciÃ³n :: [[./MoralesOrtega/MoralesOrtega.txt][MoralesOrtega.txt]]
- Archivos :: [[./MoralesOrtega/alumno_asesor_MOC.py][alumno_asesor_MOC.py]]
- Comentarios ::
  - Tu soluciÃ³n me parece un flujo interesante. Hay un par de asuntos
    a revisar, pero me parece que va bastante de cerca de lo esperado.
    - El alumno =alu()= notifica al profesor =profe()= que tiene
      alguna. Como bien dice tu comentario, /el alumno se agarra al
      profesor para que le resuelva su duda/ usando seÃ±alizaciÃ³n con
      el semÃ¡foro =profesor=. Sin embargo, parecerÃ­a que plantea su
      duda y se va â€” Â¡tal vez sin esperar a una respuesta! Yo
      sugerirÃ­a meter una seÃ±alizaciÃ³n mÃ¡s, digamos =dudaResuelta=,
      que sea adquirida por =alu()= antes de =duda.release()= y
      liberada por =profe()= despuÃ©s de =resuelveDuda()=.
    - Cuando no hay sillas (=flag==0=), el alumno =alu()= se queda
      sentado /afuera de la oficina/. Sin embargo, Â¡sÃ­ decrementa
      =numDudas=! Â¿no deberÃ­a dejar a =numDudas= para que tenga sus
      dudas completas cuando entre a hablar con el =profe()=?
- CalificaciÃ³n :: 8

** Organista Ricardo
- DocumentaciÃ³n :: [[./OrganistaRicardo/informacion.txt][informacion.txt]]
- Archivos :: [[./OrganistaRicardo/alumnos_y_asesor.py][alumnos_y_asesor.py]]
- Comentarios ::
  - Si bien manejas correctamente algunos de los puntos de
    sincronizaciÃ³n (el /Multiplex/ de =sillas= y el /Mutex/ de
    =preguntando=), te faltan algunos importantes
    - Los alumnos y el profesor no /interactÃºan/: Los dos semÃ¡foros
      que manejas regulan la comunicaciÃ³n /entre alumnos/, pero
      no hay nada que notifique al =profesor()= de que es momento de
      hacer una u otra cosa
    - Los alumnos /se responden solitos/ â€” =preguntar()= es una
      funciÃ³n donde el alumno entra, imprime, espera, y se va. Â¡SerÃ­a
      bueno nunca tener que resolver dudas, que a veces nos ponen en
      aprietos! Pero la realidad es bastante distinta...
    - Respecto a tu duda: No, en el planteamiento tradicional de
      semÃ¡foros no hay manera de conocer el contenido de una variable
      de semÃ¡foro.

      Algunas implementaciones sÃ­ te permitirÃ¡n ver si es /esperable/
      que puedas obtener o no un candado. Los candados en Python
      (=candado = threading.Lock()=) presentan la misma interfaz
      =acquire()/release()= que la que vimos, pero ademÃ¡s ofrece el
      mÃ©todo =candado.locked()=, que regresa =True= o
      =False=. Pero... yo los invito a evitar esos mÃ©todos si no es
      indispensable a la de sÃ­ o sÃ­ emplearlos.
- CalificaciÃ³n :: 6

** Rangel Jose
- DocumentaciÃ³n :: [[./RangelJose/README.md][README.md]]
- Archivos :: [[./RangelJose/asesor.py][asesor.py]]
- Comentarios ::
  - Â¡10 a 20 sillas! El dÃ­a que me quepan tantas sillas en mi
    cubÃ­culo... Â¡tal vez si me hacen director de algo! ğŸ˜‰
  - Identificaste una soluciÃ³n basada en semÃ¡foros para que el
    profesor pueda dormir la siesta, y el primer alumno que llegue lo
    despierte. Es, sÃ­, una viariaciÃ³n sobre lo que hacÃ­amos con el
    /Apagador/. Â¡Muy bien!
  - Veo Ãºnicamente como faltante un par de /Mutexes/ sibre estructuras
    comunes, que se leen o modifican en diferentes lugares del cÃ³digo
    sin ser protegidas (p.ej. =orden_preguntas=, =lista_alumnos=)
  - Â¡Muy bueno que encuentres cÃ³mo resolver las preguntas en orden!
    Ingenioso sin duda, y muy buen razonamiento que presentas. Lo
    mismo respecto a un "desordenamiento a propÃ³sito" de los alumnos.
- CalificaciÃ³n :: 9

* El elevador

** Arellano Israel
- DocumentaciÃ³n :: [[./ArellanoIsrael/ElevadorT2.txt][ElevadorT2.txt]]
- Archivos :: [[./ArellanoIsrael/elevador.py][elevador.py]]
- Comentarios ::
  - En el problema anterior felicitÃ© a los cinco alumnos que lo
    resolvieron porque los cinco pusieron los valores /duros/
    claramente anclados a valores parametrizados fuera del flujo
    central. Te sugiero adoptar esas prÃ¡cticas, te permiten realizar
    cÃ³digo mÃ¡s flexible (y te ahorran el tener que poner advertencias
    por el estilo de /Â¡todo se va a romper si no son cinco los que se
    suben!/ por todos lados.
    - Este es meramente un comentario, no te resto puntos ni
      nada. Pero es una fuerte recomendaciÃ³n.
  - Â¡Interesante soluciÃ³n usando variables de condiciÃ³n! Â¡Muy bien!
    - Me parece que esto lleva a fragmentos con lÃ³gica mÃ¡s bien
      complicada, como las verificaciones en las lÃ­neas 79--82 â€” pero
      es absolutamente correcto.
  - Muy bueno que hagas las verificaciones en =mueve_elevador()=; casi
    siempre he visto implementaciones en que el elevador baja hasta el
    0 y sube hasta el 4 independientemente de alguien lo haya llamado
    ğŸ˜‰
- CalificaciÃ³n :: 10

** Bernal Gustavo, Toledo Dilan
- DocumentaciÃ³n :: [[./BernalGustavo-ToledoDilan/Entrega.txt][Entrega.txt]]
- Archivos :: [[./BernalGustavo-ToledoDilan/Elevador.py][Elevador.py]]
- Comentarios ::
  - La idea de un /Multiplex/ para limitar el mÃ¡ximo de alumnos en el
    elevador es buena, pero... Â¡no llaman a =subir_elevador()= ni
    =bajar_elevador()=! (ni esas funciones hacen nada mÃ¡s que
    adquirir/liberar el /Multiplex/)
  - TambiÃ©n, la idea de formarse en la cola de cada piso. Â¡pero nunca
    se salen de la fila para abordar al elevador! ğŸ™
- CalificaciÃ³n :: 6

** Rojas Laylet, Ruiz Miguel
- DocumentaciÃ³n :: [[./RojasLaylet-RuizMiguel/Read.txt][Read.txt]]
- Archivos :: [[./RojasLaylet-RuizMiguel/Elevator.py][Elevator.py]]
- Comentarios ::
  - Â¡Muy bonita implementaciÃ³n! (incluyendo una buena visualizaciÃ³n
    para explicar la situaciÃ³n)
  - Como correctamente indican, =Alumno.run()= incurre en /dos/
    esperas activas. Eso no es bueno... Claro, no es trivial evitarlo:
    el elevador =System= tendrÃ­a que notificar a cada uno de los
    alumnos de las colas relevantes (y de dentro del elevador) para
    evitarlo, lo cual pondrÃ­a de cabeza la lÃ³gica que supongo ya
    llevaban desarrollada para el momento en que decidieron sÃ­ dejar
    la espera activa.
- CalificaciÃ³n :: 9

* IntersecciÃ³n de caminos

** Camacho Juan
- DocumentaciÃ³n :: [[./CamachoJuan/Tarea1.txt][Tarea1.txt]]
- Archivos :: [[./CamachoJuan/interseccion_de_caminos.py][interseccion_de_caminos.py]]
- Comentarios ::
  - Â¡Conciso y corto! Â¡Muy bien!
    - Me gustÃ³ cÃ³mo abstraes desde temprano, y cÃ³mo esto ayuda a que
      el cÃ³digo sea mÃ¡s corto y sencillo.
  - Como lo indicas, tu =Mutex= alrededor de toda la intersecciÃ³n
    evita que compartan los carriles no-rivales (p.ej. que 0 y 1 pase
    a la vez que 2 y 3)
    - Sin embargo, quitando al =Mutex= (y agregÃ¡ndole un =sleep(0.01)=
      despuÃ©s del =print= de cada cuadrante), me da una interacciÃ³n
      mucho mÃ¡s interesante:
      #+begin_src text
	Nuevo carro ğŸš— numero: 0 Voy del norte hacia el sur â¬‡ï¸
	carro: 0 ğŸ›‘ pasando por el cuadrante  0
	Nuevo carro ğŸš— numero: 1 Voy del sur hacia el norte â¬†ï¸
	carro: 1 ğŸ›‘ pasando por el cuadrante  2
	Nuevo carro ğŸš— numero: 2 Voy del sur hacia el norte â¬†ï¸
	Nuevo carro ğŸš— numero: 3 Voy del sur hacia el norte â¬†ï¸
	Nuevo carro ğŸš— numero: 4 Voy del este hacia el oeste â¬…ï¸
	carro: 4 ğŸ›‘ pasando por el cuadrante  1
	Nuevo carro ğŸš— numero: 5 Voy del oeste hacia el este â¡ï¸
	carro: 5 ğŸ›‘ pasando por el cuadrante  3
	Nuevo carro ğŸš— numero: 6 Voy del oeste hacia el este â¡ï¸
	Nuevo carro ğŸš— numero: 7 Voy del norte hacia el sur â¬‡ï¸
	Nuevo carro ğŸš— numero: 8 Voy del norte hacia el sur â¬‡ï¸
	Nuevo carro ğŸš— numero: 9 Voy del oeste hacia el este â¡ï¸
	Nuevo carro ğŸš— numero: 10 Voy del sur hacia el norte â¬†ï¸
	Nuevo carro ğŸš— numero: 11 Voy del norte hacia el sur â¬‡ï¸
	Nuevo carro ğŸš— numero: 12 Voy del norte hacia el sur â¬‡ï¸
	Nuevo carro ğŸš— numero: 13 Voy del oeste hacia el este â¡ï¸
      #+end_src
      Los cuatro cuadrantes son ocupados al mismo tiempo. Los demÃ¡s
      autos que llegan al cruce (como es tristemente habitual ğŸ˜›)
      tienen que esperar a su turno. Un rato despuÃ©s, por alguna razÃ³n
      los autos estÃ¡n acomodados para pasar sin chocarse. Ojo, bajÃ©
      el total de autos a 99, por practicidad:
      #+begin_src text
	Nuevo carro ğŸš— numero: 94 Voy del oeste hacia el este â¡ï¸
	Nuevo carro ğŸš— numero: 95 Voy del norte hacia el sur â¬‡ï¸
	Nuevo carro ğŸš— numero: 96 Voy del oeste hacia el este â¡ï¸
	Nuevo carro ğŸš— numero: 97 Voy del oeste hacia el este â¡ï¸
	Nuevo carro ğŸš— numero: 98 Voy del sur hacia el norte â¬†ï¸
	carro: 7 ğŸ›‘ pasando por el cuadrante  0
	carro: 2 ğŸ›‘ pasando por el cuadrante  2
	carro: 15 ğŸ›‘ pasando por el cuadrante  1
	carro: 6 ğŸ›‘ pasando por el cuadrante  3
	carro: 8 ğŸ›‘ pasando por el cuadrante  0
	carro: 3 ğŸ›‘ pasando por el cuadrante  2
	carro: 21 ğŸ›‘ pasando por el cuadrante  1
      #+end_src
      Y por Ãºltimo, van saliendo; cada vez que uno deja el Ãºltimo
      cuadrante que ocupaba, notifica:
      #+begin_src text
	carro: 63 ğŸ›‘ pasando por el cuadrante  3
	carro ğŸš— numero: 27 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	carro: 30 ğŸ›‘ pasando por el cuadrante  2
	carro ğŸš— numero: 53 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	carro: 55 ğŸ›‘ pasando por el cuadrante  0
	carro ğŸš— numero: 48 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	carro: 51 ğŸ›‘ pasando por el cuadrante  1
	carro ğŸš— numero: 63 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	carro: 64 ğŸ›‘ pasando por el cuadrante  3
	carro ğŸš— numero: 30 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	carro: 37 ğŸ›‘ pasando por el cuadrante  2
      #+end_src
    - El Ãºnico problema con esto es que una gran cantidad de autos se
      estarÃ­a quedando en la rayita del camellÃ³n... Pero... Â¿Y si
      limitamos el total de autos en el cruce a un nÃºmero
      decente... Digamos, 6? Revivamos tu =Mutex= y convirtÃ¡moslo en
      un /Multiplex/ inicializÃ¡ndolo a =Semaphore(6)=, y la
      interacciÃ³n se ve, desde el principio, mucho mÃ¡s interesante:
      #+begin_src text
	Nuevo carro ğŸš— numero: 0 Voy del norte hacia el sur â¬‡ï¸
	carro: 0 ğŸ›‘ pasando por el cuadrante  0
	carro: 0 ğŸ›‘ pasando por el cuadrante  3
	carro ğŸš— numero: 0 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	Nuevo carro ğŸš— numero: 1 Voy del oeste hacia el este â¡ï¸
	carro: 1 ğŸ›‘ pasando por el cuadrante  3
	carro: 1 ğŸ›‘ pasando por el cuadrante  2
	carro ğŸš— numero: 1 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	Nuevo carro ğŸš— numero: 2 Voy del norte hacia el sur â¬‡ï¸
	carro: 2 ğŸ›‘ pasando por el cuadrante  0
	carro: 2 ğŸ›‘ pasando por el cuadrante  3
	Nuevo carro ğŸš— numero: 3 Voy del norte hacia el sur â¬‡ï¸
	carro: 3 ğŸ›‘ pasando por el cuadrante  0
	carro ğŸš— numero: 2 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	carro: 3 ğŸ›‘ pasando por el cuadrante  3
	Nuevo carro ğŸš— numero: 4 Voy del oeste hacia el este â¡ï¸
	carro ğŸš— numero: 3 Sali del cruce!!! ğŸ‰ğŸ‰ğŸ‰
	Nuevo carro ğŸš— numero: 5 Voy del oeste hacia el este â¡ï¸
	Nuevo carro ğŸš— numero: 7 Voy del oeste hacia el este â¡ï¸
	Nuevo carro ğŸš— numero: 8 Voy del sur hacia el norte â¬†ï¸
	Nuevo carro ğŸš— numero: 9 Voy del este hacia el oeste â¬…ï¸
	carro: 4 ğŸ›‘ pasando por el cuadrante  3
	Nuevo carro ğŸš— numero: 6 Voy del norte hacia el sur â¬‡ï¸
	carro: 9 ğŸ›‘ pasando por el cuadrante  1
	carro: 6 ğŸ›‘ pasando por el cuadrante  0
	carro: 5 ğŸ›‘ pasando por el cuadrante  3
	carro: 8 ğŸ›‘ pasando por el cuadrante  2
      #+end_src
- CalificaciÃ³n :: 9

** Miranda Juan
- DocumentaciÃ³n :: [[./MirandaJuan/tarea_1.txt][tarea_1.txt]]
- Archivos :: [[./MirandaJuan/tarea1_interseccion_de_caminos.py][tarea1_interseccion_de_caminos.py]]
- Comentarios ::
  - La lÃ³gica que implementas no resuelve al problema planteado
    - La barrera para que sÃ³lo pasen los autos de 5 en 5 no tiene nada
      que ver con el planteamiento
    - No estÃ¡ modelada la intersecciÃ³n
    - Por mÃ¡s que confundiste escribiendo =Choches= en vez de
      =Coches=, no hay posibilidad alguna de =choques= ğŸ˜‰
- CalificaciÃ³n :: 6

** Rios Gamaliel
- DocumentaciÃ³n :: [[./RiosGamaliel/README.md][README.md]]
- Archivos :: [[./RiosGamaliel/1/Carril.java][Carril.java]], [[./RiosGamaliel/1/InterseccionCaminos.java][InterseccionCaminos.java]], [[./RiosGamaliel/1/TipoAuto.java][TipoAuto.java]], [[./RiosGamaliel/2/Carril.java][Carril.java]], [[./RiosGamaliel/2/InterseccionCaminos.java][InterseccionCaminos.java]], [[./RiosGamaliel/2/TipoAuto.java][TipoAuto.java]], [[./RiosGamaliel/2/TipoCarril.java][TipoCarril.java]]
- Comentarios ::
  - Es bueno que me saquen de la monotonÃ­a ğŸ˜‰ Â¡Gracias por escribir en
    un lenguaje distinto de Python!
    - LÃ¡stima que fuera Java... Tengo alguna especie de bloqueo
      mental, Â¡y nomÃ¡s no puede caerme bien ese lenguaje!
    - (... pero esa es bronca mÃ­a. Â¡Muy bien por hacerlo!)
  - Â¡Muy bien por encontrar la situaciÃ³n de bloqueo mutuo, y hacer que
    sea imposible que se presente
    - Ojo, lo que describes es /bloqueo mutuo/, no /inaniciÃ³n/.
  - TambiÃ©n buena: tu idea de adquirir =frente2= antes de liberar
    =frente1= (y, por tanto, imposibilitar el que nos quedemos
    atrapados en el camellÃ³n esperando un mutex, como describo que le
    pasÃ³ a mi modificaciÃ³n del programa de Juan Camacho).
  - Y muy bueno cÃ³mo aprovechaste los mecanismos especÃ­ficos de
    sincronizaciÃ³n de la VM de Java (como =synchronized=). Â¡Yo creÃ­a
    que sÃ³lo se podÃ­a anotar como =synchronized= a un mÃ©todo completo!
- CalificaciÃ³n :: 10

** Uriarte Yahir
- DocumentaciÃ³n :: [[./UriarteYahir/Tarea1_Uriarte_Yahir.txt][Tarea1_Uriarte_Yahir.txt]]
- Archivos :: [[./UriarteYahir/IntersecciondeCaminos.py][IntersecciondeCaminos.py]], [[./UriarteYahir/IntersecciondeCaminosF.py][IntersecciondeCaminosF.py]]
- Comentarios ::
  - Â¡Ojo con la ortografÃ­a! No se escribe Â«zÂ» antes de Â«eÂ», por lo que
    la palabra correcta es Â«cruceÂ», no Â«cruzeÂ». La leÃ­ ya tantas veces
    que... no puedo seguir leyendo sin hacerlo explÃ­cito ğŸ˜‰
  - Revisando el error a que haces referencia, la respuesta casi
    siempre la tienes en el punto en que indica el tipo de excepciÃ³n
    que ocurriÃ³, =RuntimeError=. Reproduzco de tu documentaciÃ³n, para
    que quede mÃ¡s a mano para tus compaÃ±eros:
    #+begin_src text
      Traceback (most recent call last):

	File C:\Program Files\Spyder\pkgs\spyder_kernels\py3compat.py:356 in compat_exec
	  exec(code, globals, locals)

	File c:\users\yahir\documents\fi unam\semestre_2023-2\sistemas operativos\untitled6.py:165
	  thread.join()

	File threading.py:1008 in join

      RuntimeError: cannot join current thread
    #+end_src
    Esto es causado por el siguiente cÃ³digo:
    #+begin_src python
      for thread in threading.enumerate():#Enumerar hilos.
	  if thread.daemon:
	      continue
	  try:
	      thread.join()
	  except RuntimeError as err:
	      if 'Error' in err.args[0]:
		  continue
	      else:
		  raise
    #+end_src
    La Ãºltima lÃ­nea de tu mensaje de error (no entiendo quÃ© busca el
    bloque =except= que le agregaste) se presenta porque =cannot join
    current thread=: No puedes pedir que el hilo actual espere para
    unirse consigo mismo. Si quieres evitar ese mensaje, usa el
    siguiente contenido para el bloque =expect=:
    #+begin_src python
      if thread != threading.current_thread():
	  thread.join()
    #+end_src
  - Me entregas dos implementaciones, pero... Â¿CuÃ¡l se supone que
    revise? Viendo rÃ¡pidamente tu descripciÃ³n, me parece que la
    "mejor" es =IntersecciondeCaminos.py= comprenderÃ¡s que no revise
    ambas (Â¡requieren su tiempo!)
  - Tu cÃ³digo no evita (sÃ³lo detecta) las colisiones: Es frecuente que
    veamos que =ya cochocaron ğŸš‘ğŸš‘ğŸš‘ğŸš‘ğŸš‘=.
  - Me parece que caes en un bloqueo mutuo: Si bien a veces el
    programa ejecuta correctamente, casi siemprese presenta un bloqueo
    mutuo. Al interrumpirlo me indica que:
    #+begin_src text
      ^CTraceback (most recent call last):
	File "/home/gwolf/vcs/sistop-2023-2/tareas/1/UriarteYahir/IntersecciondeCaminos.py", line 85, in <module>
	  thread.join()
	File "/usr/lib/python3.11/threading.py", line 1112, in join
	  self._wait_for_tstate_lock()
	File "/usr/lib/python3.11/threading.py", line 1132, in _wait_for_tstate_lock
	  if lock.acquire(block, timeout):
	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      KeyboardInterrupt
    #+end_src
    - Pero esto sÃ³lo me indica que el hilo principal se quedÃ³
      esperando en el =join()=, no me dice dÃ³nde se quedaron los otros hojis.

    - Puedes depurarlo mÃ¡s, me gustarÃ­a que nos cuentes en quÃ© te
      atoraste ğŸ˜‰
    
- CalificaciÃ³n :: 7

* El cruce del rÃ­o

** Frias Camille
- DocumentaciÃ³n :: [[./FriasCamille/Explicacion.txt][Explicacion.txt]]
- Archivos :: [[./FriasCamille/convenciÃ³n.py][convenciÃ³n.py]]
- Comentarios ::
  - Â¡Deja de lado el /pensamiento mÃ¡gico/! Si tienes un error que no
    siempe se presenta, no es /por misterios de la vida/... Casi
    seguramente es una condiciÃ³n de carrera, y tienes todo lo
    necesario para corregirla ğŸ˜‰
    - "Desafortunadamente"... EjecutÃ© varias veces el programa, y
      nunca lo vi fallar...
    - Siempre que puedas, recuerda el principio "DRY": /Don't Repeat
      Yourself/. *No te repitas*.

      Si tienes dos funciones no-triviales tan similares como
      =hacker()= y =serf()=, convendrÃ­a plantear un parÃ¡metro que
      definiera su comportamiento, posiblemente las cadenas que
      imprime... y escribir Ãºnicamente una vez la lÃ³gica. AsÃ­ como lo
      hiciste, cualquier cambio o correcciÃ³n que tengas que hacer,
      debes hacerla en dos lugares. Es mÃ¡s trabajo mantenerlo, al
      igual que verificar que ambas copias funcionen bien.
  - La lÃ³gica del programa me parece correcta y simple. Â¡Muy bien!
- CalificaciÃ³n :: 10

** JuÃ¡rez Cristopher, Constantino Pablo
- DocumentaciÃ³n :: [[./ConstantinoPablo-JuarezCristopher/README.md][README.md]]
- Archivos :: [[./ConstantinoPablo-JuarezCristopher/CruceRio.py][CruceRio.py]]
- Comentarios ::
  - Su lÃ³gica general es buena, y (Â¡bien!) utilizan mecanismos de
    sincronizaciÃ³n para detener / seÃ±alizar a los hilos.

    Sin embargo, hacen muchas verificaciones y modificaciones a
    variables globales (=num_Hackers=, =num_Serfs=) sin emplear un
    /Mutex/ para protegerlas de accesos simultÃ¡neos.
- CalificaciÃ³n :: 8

** Marquez Axel
- DocumentaciÃ³n :: [[./MarquezAxel/Especificacion.txt][Especificacion.txt]]
- Archivos :: [[./MarquezAxel/CruceRio.py][CruceRio.py]]
- Comentarios ::
  - Conciso, cortito, y fÃ¡cil de leer. Â¡Bien! ğŸ˜ƒ
  - Sin embargo... Caes en bloqueo mutuo siempre, despuÃ©s de lanzar la
    primera balsa ğŸ˜¢
    - Todos tus hilos hacen un =balsa.acquire()=, pero el Ãºltimo (el
      que ve que ya son 4 y le "da la patada" a la balsa) no lo
      hace. Esto es fÃ¡cil de corregir: Tanto en =lanza_serf()= como en
      =lanza_hacker()= reemplaza el Ãºltimo caso del =if=, de:
      #+begin_src python
      else:
        balsa.release()
      #+end_src
      para que quede:
      #+begin_src python
      else:
        balsa.release()
      #+end_src
    - Pero todavÃ­a no sirve bien ğŸ™ Ahora se llenan 3 balsas, pero
      siguen llegando hilos... y no sale ningun mÃ¡s â˜¹

      Esto es, me parece, porque usas =serf_cont= como un contador,
      pero nunca lo decrementas â€” y haces las comparaciones =if
      serf_cont == Max=, =if serf_cont == 2 and hacker_cont == 2= y
      =if hacker_cont == 4=
  - El cÃ³digo /muy en general/ funciona, la lÃ³gica es correcta,
    pero... le faltan /varias/ pequeÃ±as precisiones.
- CalificaciÃ³n :: 7

** Martinez Licea, Santiago Alejandro
- DocumentaciÃ³n :: [[./MartinezLicea-SantiagoAlejandro/README.md][README.md]]
- Archivos :: [[./MartinezLicea-SantiagoAlejandro/balsa.py][balsa.py]]
- Comentarios ::
  - El cÃ³digo como lo mandaron no sirve : Si todos hacen un
    =semaforoH.acquire()= o =semaforoS.acquire()= al iniciar, y Ã©stos
    estÃ¡n inicializados a 0, todos los hilos se quedan dormidos para
    siempre
  - Los mensaje =La balsa ha cruzado= y =La balsa ha regresado= son
    impresos de forma no condicional, por cualquier hilo que pase por
    ahÃ­
  - La lÃ³gica para maneajar el conteo de navegantes... no existe ğŸ™
- CalificaciÃ³n :: 6

** Oronzor Manases
- DocumentaciÃ³n :: [[./OronzorManases/Informe.txt][Informe.txt]]
- Archivos :: [[./OronzorManases/El_cruce_del_rio.py][El_cruce_del_rio.py]]
- Comentarios ::
  - Respecto a tu duda: hay muchas maneras en que podrÃ­as interrumpir
    la condiciÃ³n dependiendo de varias condiciones. En vez de lanzar
    los hilos dentro de un =while True=, podrÃ­as generar un nÃºmero
    predefinido de hilos:
    #+begin_src python
      desarrolladores = 0
      while desarrolladores < 40:
	  if random.randint(0, 1) == 0:
	      threading.Thread(target=hacker,).start()
	  else:
	      threading.Thread(target=serf,).start()
    #+end_src
    PodrÃ­as contar el nÃºmero de balsas que han cruzado. PodrÃ­as
    hacerlo basado en tiempo, o en entrada de teclado... Â¡lo que quieras!
    - Siempre que puedas, recuerda el principio "DRY": /Don't Repeat
      Yourself/. *No te repitas*.

      Si tienes dos funciones no-triviales tan similares como
      =hacker()= y =serf()=, convendrÃ­a plantear un parÃ¡metro que
      definiera su comportamiento, posiblemente las cadenas que
      imprime... y escribir Ãºnicamente una vez la lÃ³gica. AsÃ­ como lo
      hiciste, cualquier cambio o correcciÃ³n que tengas que hacer,
      debes hacerla en dos lugares. Es mÃ¡s trabajo mantenerlo, al
      igual que verificar que ambas copias funcionen bien.
- CalificaciÃ³n :: 10

** Paniagua Eduardo
- DocumentaciÃ³n :: [[./PaniaguaEduardo/tarea01_eduardoPaniagua.txt][tarea01_eduardoPaniagua.txt]]
- Archivos :: [[./PaniaguaEduardo/tarea01_eduardoPaniagua.py][tarea01_eduardoPaniagua.py]]
- Comentarios ::
  - Buena implementaciÃ³n
  - Â¡Ojo! En tu documentaciÃ³n dices que /Para resolver este ejercicio
    se ocuparon 2 hilos, uno que corresponde a los serfs y otro que
    corresponde a los hackers/. Â¿EstÃ¡s seguro? ğŸ˜‰

    AquÃ­, en efecto, lanzas dos hilos:
    #+begin_src python
      Thread(target=lanzarSerf).start()
      Thread(target=lanzarHacker).start()
    #+end_src
    - Sin embargo, tanto en =lanzarSerf()= como en =lanzarHacker()=
      tienes:
      #+begin_src python
	for i in range(12):
	    Thread(target=serf, args=[i].start()
      #+end_src
    - AsÃ­ que trabajas con 1 (hilo principal) + 2 (lanzarHacker y
      lanzarSelf), + 12 hackers + 12 serfs.
- CalificaciÃ³n :: 10

** Ramirez Daniel
- DocumentaciÃ³n :: [[./RamirezDaniel/ProblemaCruceDelRÃ­o.txt][ProblemaCruceDelRÃ­o.txt]]
- Archivos :: [[./RamirezDaniel/cruceDelRio.py][cruceDelRio.py]]
- Comentarios ::
  - Tu cÃ³digo estÃ¡ hecho para resopnder a un nÃºmero exacto de /serfs/
    y /hackers/, y sÃ³lo responde a sus respectivas llegadas de la
    misma proporciÃ³n.
  - Lanzas un hilo para hackers, un hilo para threads, y un hilo para
    cruzar juntos
    - SerÃ­a como poner tres balsas en el rÃ­o, cada una de ellas
      "reservada" para una composiciÃ³n especÃ­fica de usuarios
- CalificaciÃ³n :: 7

** Rivera Mauricio, Ruiz Laura
- DocumentaciÃ³n :: [[./RiveraMauricio-RuizLaura/README.md][README.md]]
- Archivos :: [[./RiveraMauricio-RuizLaura/balsas.py][balsas.py]]
- Comentarios ::
  - Â¡Muy bien por parametrizar todo! De hecho, esta soluciÃ³n me da pie
    a pensar en un /refinamiento/: Â¿Y cÃ³mo lo haces si el nÃºmero de
    asientos es parametrizable? Â¿Funciona si =soporte_barca=6= ? Â¡sÃ­,
    sÃ­ funciona! Tienen que entrar de 2 en 2, pero pueden entrar hasta
    6 ğŸ˜‰
  - Â¡Felicidades, muy buen trabajo!
- CalificaciÃ³n :: 10

** Rojo Luis
- DocumentaciÃ³n :: [[./RojoLuis/cruce_del_rio_doc.txt][cruce_del_rio_doc.txt]]
- Archivos :: [[./RojoLuis/cruce_del_rio.py][cruce_del_rio.py]]
- Comentarios ::
  - Â¡Muy bueno, que encuentres inspiraciÃ³n en otros problemas vistos
    en clase! ğŸ˜‰ Muy bonita idea el uso de intermediarios. Â¡Y muy
    orignal!
- CalificaciÃ³n :: 10

** Sotelo Axel
- DocumentaciÃ³n :: [[./SoteloAxel/reporte.txt][reporte.txt]]
- Archivos :: [[./SoteloAxel/tarea1.py][tarea1.py]]
- Comentarios ::
  - Siempre que puedas, recuerda el principio "DRY": /Don't Repeat
    Yourself/. *No te repitas*.

    Si tienes dos funciones no-triviales tan similares como
    =hacker()= y =serf()=, convendrÃ­a plantear un parÃ¡metro que
    definiera su comportamiento, posiblemente las cadenas que
    imprime... y escribir Ãºnicamente una vez la lÃ³gica. AsÃ­ como lo
    hiciste, cualquier cambio o correcciÃ³n que tengas que hacer,
    debes hacerla en dos lugares. Es mÃ¡s trabajo mantenerlo, al
    igual que verificar que ambas copias funcionen bien.
  - Â¡EncontrÃ© el problema en tu lÃ³gica que hace que tengas que
    inicializar =lugaresBalas= a 5:
    - Recuerda que les expliquÃ© que indentar un bloque bajo =with
      lugaresBalas:= es equivalente a rodearlo con un
      =lugaresBalas.acquire()= / =lugaresBalas.release()=.
    - Entonces, para fines prÃ¡cticos, para hacer cualquier cosa en
      =hacker()= o en =serf()= necesitas tener /dos veces/ el mismo
      =Multiplex=.
    - Â¿QuÃ© hacer? Quita uno o el otro. Puede quedar asÃ­:
      #+begin_src python
	def hacker():
	    global numHackers
	    print("hacker llega âš«")

	    while True:
		time.sleep(random.random())
		with lugaresBalas:
		    persona = 'hacker'
		    print(f"{persona} {numHackers} se pone en fila para subir")
		    numHackers = numHackers+1

		lugaresBalas.release()
#+end_src
- CalificaciÃ³n :: 9

* Santa Claus

** Garcia Lopez, Martinez Julio
- DocumentaciÃ³n :: [[./GarciaLopez-MartinezJulio/ExplicacionTarea1SO.txt][ExplicacionTarea1SO.txt]]
- Archivos :: [[./GarciaLopez-MartinezJulio/Tarea1SO.py][Tarea1SO.py]]
- Comentarios ::
  - Â¡Muy bien! Me gusta cÃ³mo usan a =SemSanta= como un anÃ¡logo a /dos/
    barreras distintas (el mismo semÃ¡foro se abre con 9 renos o con 3
    elfos).
  - Â¡Ojo! Falta un par de mutexes para proteger el acceso concurrente
    a variables globales (p.ej. para =numRenos= en =reno()=, para
    =numElfos= en =elfo()=
  - Y ya que estamos criticando todo lo criticable ğŸ˜‰ Â¡Todos los aÃ±os
    debe haber navidad! *Â¡TODOS!* Â¿QuÃ© es eso de terminar despuÃ©s de
    sÃ³lo un recorrido? Si hay un ejemplo de =while True=, ese deberÃ­a
    ser Santa Claus ğŸ˜‰
- CalificaciÃ³n :: 8

** Meneses Erick, Mex Aerin
- DocumentaciÃ³n :: [[./MenesesErick-MexAerin/README.txt][README.txt]]
- Archivos :: [[./MenesesErick-MexAerin/Tarea1-Santa.py][Tarea1-Santa.py]]
- Comentarios ::
  - Muy buena implementaciÃ³n y *muy* buena documentaciÃ³n. Clara y
    detallada. Â¡Felicidades! ğŸ˜ƒ
- CalificaciÃ³n :: 10

** Sanchez Marco, Teran Mario
- DocumentaciÃ³n :: [[./SanchezMarco-TeranMario/README.md][README.md]]
- Archivos :: [[./SanchezMarco-TeranMario/main.c][main.c]]
- Comentarios ::
  - Â¡Muy bien! Â¡TodavÃ­a hay gente que se anima a resolver mis
    problemas en lenguajes que no sean Python! ğŸ˜‰ Â¡Bienvenido C!
  - No se disculpen por la acentuaciÃ³n (que no /asentuasion/):
    CorrÃ­janla. En serio, es un punto importante. Yo uso teclado
    en_US; hay muchas manteras de configurarle teclas para
    acentuar. Yo uso un teclado definido a medida en =xkb=.
  - Curioso el orden de eventos que manejan para despertar a Santa
    - En la bitÃ¡cora aparece:
      #+begin_quote
      Santa esta durmiendo.
      Elfo 2 le da lata a Santa Claus.
      Elfo 1 le da lata a Santa Claus.
      Santa se despierta y ayuda a los elfos.
      Elfo 3 le da lata a Santa Claus.
      Santa se despierta e inicia su recorrido.
      Reno 2 regresa de sus vacaciones y esta listo.
      Reno 4 regresa de sus vacaciones y esta listo.
      Reno 3 regresa de sus vacaciones y esta listo.
      Reno 8 regresa de sus vacaciones y esta listo.
      Reno 6 regresa de sus vacaciones y esta listo.
      Reno 9 regresa de sus vacaciones y esta listo.
      Reno 1 regresa de sus vacaciones y esta listo.
      Reno 5 regresa de sus vacaciones y esta listo.
      Reno 7 regresa de sus vacaciones y esta listo.
      #+end_quote
    - RevisÃ© la lÃ³gica, y es correcta... Pero... Â¿CÃ³mo estÃ¡ eso de que
      Santa se despierta e inicia su recorrido... /Justo antes/ de que
      lleguen los renos? Â¿SerÃ¡ que los estÃ¡ queriendo reemplazar por
      una mÃ¡quina frÃ­a y sin corazÃ³n?
    - Como dije, la lÃ³gica es /casi/ correcta. Yo sugerirÃ­a cambiar
      sÃ³lo el punto del =printf=. En su versiÃ³n:
      #+begin_src c
	if(no_renos == NO_TOTAL_RENOS) {
		printf("Santa se despierta e inicia su recorrido.\n");
		for(int i=0; i<NO_TOTAL_RENOS; i++)
			sem_post(&sem_reno);
		no_renos = 0;
	} else if(no_elfos == NO_PERMITIDO_ELFOS)
		printf("Santa se despierta y ayuda a los elfos.\n");
      #+end_src
      Yo harÃ­a:
      #+begin_src c
	if(no_renos == NO_TOTAL_RENOS) {
		for(int i=0; i<NO_TOTAL_RENOS; i++)
			sem_post(&sem_reno);
		no_renos = 0;
		printf("Santa se despierta e inicia su recorrido.\n");
	} else if(no_elfos == NO_PERMITIDO_ELFOS)
		printf("Santa se despierta y ayuda a los elfos.\n");
      #+end_src
    - Algo parecido con los elfos: Imprimir =Elfo %d le da lata a Santa
      Claus= ocurre /casi/ siempre dos veces, luego se despierta
      Santa, y luego vuelve a imprimirse.
- CalificaciÃ³n :: 10

** Solis Alan
- DocumentaciÃ³n :: [[./SolisAlan/Explicacion.txt][Explicacion.txt]]
- Archivos :: [[./SolisAlan/santa.py][santa.py]]
- Comentarios ::
  - Bueno... Como verÃ¡s que le respondÃ­ a tu compaÃ±ero Fernando, hubo
    al menos un caso de otro compaÃ±ero que sÃ­ resolviÃ³ (de una forma
    distinta a la que hicimos en clase) el problema de gatos y
    ratones.
    - Â¡pero quÃ© bueno que tÃº sÃ­ seguiste las indicaciones! ğŸ˜‰
  - OK, veo varias partes de la soluciÃ³n muy bien implementadas en tu
    problema. Muy bien por identificar e implementar a las barreras.
  - Me parece interesante que sea =Santa()= quien realice las
    verificaciones (si ya son suficientes =elfos()= o =renos()=) y suelte las
    llamadas para que estos despierten / continÃºen.
- CalificaciÃ³n :: 10

** VÃ¡zquez Fredin
- DocumentaciÃ³n :: [[./VÃ¡zquezFredin/Images/1.jpg][1.jpg]], [[./VÃ¡zquezFredin/Images/2.jpg][2.jpg]], [[./VÃ¡zquezFredin/Images/demo.gif][demo.gif]], [[./VÃ¡zquezFredin/README.md][README.md]]
- Archivos :: [[./VÃ¡zquezFredin/Santa_problem.py][Santa_problem.py]]
- Comentarios ::
  - Â¡Guau! Tu documentaciÃ³n me dejÃ³ francamente
    sorprendido. Â¡BuenÃ­sima, super completa y bastante clara! ğŸ˜ƒ
  - RecomendaciÃ³n pra el cÃ³digo: Me parece muy buena tu idea de
    mantener la legibilidad separando el cÃ³digo de los mensajes que se
    imprimen. Sin embargo, es mÃ¡s claro (e incluso, tÃ­picamente mÃ¡s
    rÃ¡pido, aunque en el nivel de lo Ã­nfimo) usar un hash
    ("diccionario" en Python) que una cantidad de funciones. Esto,
    ademÃ¡s, te permite separar los mensajes temÃ¡ticamente. Por
    ejemplo, en vez de:
    #+begin_src python
      def inicio_viaje():
	  print(Fore.LIGHTGREEN_EX +"\t\t\t\t * Santa inicia el viaje *  \U0001F30E \n\t      \U0001F384      \U0001F381 F e l i z  N a v i d a d !   H o !   H o !   H o !  \U0001F381"+ Style.RESET_ALL)

      def ayudar_elfos():
	  print(Fore.GREEN+"\t\tÂ¿En quÃ© les puedo ayudar?         * Empieza asesorar *"+ Style.RESET_ALL)

      def santa_regresa():
	  print(Fore.LIGHTBLUE_EX+" > * Santa Claus regresa del viaje muy cansado y se va a dormir \U0001F6CC *"+ Style.RESET_ALL)

      def santa_duerme():
	  print(Fore.LIGHTBLUE_EX+"* Santa Claus vuelve a dormir \U0001F6CC *"+ Style.RESET_ALL)

      def reno_llega(num):
	  print(f"\t * El reno {num} \U0001F98C regresÃ³ de sus vacaciones *")

      def renos_descansan():
	  print("* El reno procede a descansar en el establo \U0001F4A4 *")

      def reno_aviso(id):
	  print(Fore.LIGHTYELLOW_EX + f"\t\t### Ha llegado el Ãºltimo reno ###          ~~ Ahora el reno {id} se dirige con Santa Claus ~~" + Style.RESET_ALL)

      def renos_preparados(num):
	  print(f"\t\t~~~~~~      El reno {num} ya estÃ¡ listo para el viaje!      ~~~~~~")

      def renos_vacacionar():
	  print(Fore.LIGHTRED_EX+" > * Los renos vuelven a ir de vacaciones \U0001F3D6 *"+ Style.RESET_ALL)

      def grupo_formado_aviso(num):
	  print(Fore.LIGHTYELLOW_EX+f"\t> Elfo nÃºmero {num}: El grupo ya estÃ¡ formado Â¡Ya podemos preguntar!  \U0001F512\U0001F5DD"+ Style.RESET_ALL)

      def elfo_recibe_ayuda(id):
	  print(f"* Elfo nÃºmero {id} recibe ayuda por parte de Santa Claus *")
    #+end_src
    yo te sugerirÃ­a usar:
    #+begin_src python
      cadenas = {
	  'santa': {
	      # (...)
	      'inicio_viaje': Fore.LIGHTGREEN_EX +"\t\t\t\t * Santa inicia el viaje *  \U0001F30E \n\t      \U0001F384      \U0001F381 F e l i z  N a v i d a d !   H o !   H o !   H o !  \U0001F381"+ Style.RESET_ALL,
	      'ayudar_elfos': Fore.GREEN+"\t\tÂ¿En quÃ© les puedo ayudar?         * Empieza asesorar *"+ Style.RESET_ALL,
	      'regresa': Fore.LIGHTBLUE_EX+" > * Santa Claus regresa del viaje muy cansado y se va a dormir \U0001F6CC *"+ Style.RESET_ALL,
	      'duerme': Fore.LIGHTBLUE_EX+"* Santa Claus vuelve a dormir \U0001F6CC *"+ Style.RESET_ALL,
	      },
	  'reno': {
	      'llega': f"\t * El reno {num} \U0001F98C regresÃ³ de sus vacaciones *",
	      'descansa': "* El reno procede a descansar en el establo \U0001F4A4 *",
	      'aviso': Fore.LIGHTYELLOW_EX + f"\t\t### Ha llegado el Ãºltimo reno ###          ~~ Ahora el reno {id} se dirige con Santa Claus ~~" + Style.RESET_ALL,
	      'preparados': f"\t\t~~~~~~      El reno {num} ya estÃ¡ listo para el viaje!      ~~~~~~"
	      'vacaciona': Fore.LIGHTRED_EX+" > * Los renos vuelven a ir de vacaciones \U0001F3D6 *"+ Style.RESET_ALL,
	      'grupo_formado_aviso': Fore.LIGHTYELLOW_EX+f"\t> Elfo nÃºmero {num}: El grupo ya estÃ¡ formado Â¡Ya podemos preguntar!  \U0001F512\U0001F5DD"+ Style.RESET_ALL
	  },
	  'elfo': {
	      'recibe_ayuda': f"* Elfo nÃºmero {id} recibe ayuda por parte de Santa Claus *"
	      # (...)
	      }
	  }`
    #+end_src

    Claro, manejas alguns cadenas de formato, que habrÃ­a que cambiar
    por los formatos tipo C ('%d' y similares) y substituirlos en la
    llamada. Otra idea serÃ­a cambiar las constantes de =colorama= por
    valores de mÃ¡s fÃ¡cil lectura que un =Fore.LIGHTYELLOW_EX= o
    similares.
- CalificaciÃ³n :: 10

* Gatos y ratones

** Razo Fernando
- DocumentaciÃ³n :: [[./RazoFernando/TAREA 1 Ejercicios de sincronizaciÃ³n.pdf][TAREA 1 Ejercicios de sincronizaciÃ³n.pdf]]
- Archivos :: [[./RazoFernando/gatosYRatones.py][gatosYRatones.py]]
- Comentarios ::
  - Pero, pero... Â¡Este problema lo resolvimos en clase!
    Â¡Supuestamente este ya no estaba "abierto" para solucionar!
    - Lo doy por bueno, tu respuesta es suficientemente distinta y
      original a la que hicimos. Pero igual me sacÃ³ de onda ğŸ˜‰
  - Me parece interesante que el "control poblacional" recae por
    completo en los ratones â€” es dentro de =RatonCome()= que se
    detecta si hay algÃºn gato y si Ã©ste se comiÃ³ al ratÃ³n
- CalificaciÃ³n :: 10

